#version 450

///////////////////////////////////////////////////////////////////////////////
// Noise section, move this to a different file so everyone can use

const uint PRIME_A = 2654435761;
const uint PRIME_B = 2246822519;
const uint PRIME_C = 3266489917;
const uint PRIME_D = 668265263;
const uint PRIME_E = 374761393;

uint hash_make (int seed) {
	return uint(seed) + PRIME_E;
}

uint rotate_left(uint data, uint steps) {
	return (data << steps) | (data >> (32 - steps));
}

uint hash_eat (uint hash, int data) {
	return rotate_left(hash + uint(data) * PRIME_C, 17) * PRIME_D;
}

uint hash_get_uint (uint hash) {
	uint avalanche = hash;
	avalanche = avalanche ^ (avalanche >> 15);
	avalanche *= PRIME_B;
	avalanche = avalanche ^ (avalanche >> 13);
	avalanche *= PRIME_C;
	avalanche = avalanche ^ (avalanche >> 16);
	return avalanche;
}

float hash_get_float (uint hash) {
	return float(hash_get_uint(hash)) / 4294967295.0;
}

vec3 random_color (int seed) {
	uint hash = hash_make(seed);
	return vec3 (
		hash_get_float(hash_eat(hash, int(PRIME_A))),
		hash_get_float(hash_eat(hash, int(PRIME_C))),
		hash_get_float(hash_eat(hash, int(PRIME_E)))
	);
}

vec2 random_vec2 (ivec2 seed) {
	return vec2 (
		hash_get_float(hash_eat(hash_make(seed.x), seed.y)),
		hash_get_float(hash_eat(hash_make(seed.y), seed.x))
	);
}

float value_noise_2D(float x, float y, int seed) {
	int ix0 = int(floor(x));
	int ix1 = ix0 + 1;
	float tx = smoothstep(0, 1, x - ix0);

	int iy0 = int(floor(y));
	int iy1 = iy0 + 1;
	float ty = smoothstep(0, 1, y - iy0);

	uint h = hash_make(seed);

	uint h0 = hash_eat(h, ix0);
	uint h1 = hash_eat(h, ix1);

	uint h00 = hash_eat(h0, iy0);
	uint h10 = hash_eat(h1, iy0);
	uint h01 = hash_eat(h0, iy1);
	uint h11 = hash_eat(h1, iy1);

	float v00 = hash_get_float(h00);
	float v10 = hash_get_float(h10);
	float v01 = hash_get_float(h01);
	float v11 = hash_get_float(h11);

	float v0 = mix(v00, v10, tx);
	float v1 = mix(v01, v11, tx);

	float v = mix(v0, v1, ty);

	return v;
}

// End noise section
///////////////////////////////////////////////////////////////////////////////

const float pi = 3.14159265359;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

uniform sampler2D placement_texture;

// x: world_seed;
// y: world_to_grid_scale;
// z: terrain_z_scale;
// w: voronoi cell size
uniform vec4 noise_params;

// xy: chunk min corner position xy
// z: chunk size xy (Todo(Leo): constant?)
// w: grass blades in chunk 1D (Todo(Leo): constant?)
uniform vec4 chunk_params;

// xy: world min corner position xy
// z: world size xy
uniform vec4 world_params;

// x: base_height
// y: height_variation
// z: width
// w: bend
uniform vec4 grass_params;

struct GrassInstanceData {
	vec3 position;
	float rotation;
	vec2 field_uv;
	float height;
	float width;
	vec3 test_color;
	float bend;
	vec2 facing;
	vec2 more_data;
};

layout (std430, binding = 0) buffer grass {
	GrassInstanceData instances [];
};

float sample_height (float x, float y) {
	// transform to grid scale
	x *= noise_params.y;
	y *= noise_params.y;

	return value_noise_2D(x, y, int(noise_params.x)) * noise_params.z;
}

void main() {
	uint index = gl_GlobalInvocationID.x + 
				uint(chunk_params.w) * gl_GlobalInvocationID.y;
	uint cell_x = gl_GlobalInvocationID.x;
	uint cell_y = gl_GlobalInvocationID.y;

	// Todo(Leo): make hash based on base position, not index, to not swap hash when
	// blending lods
	uint hash = hash_make(int(index));
	uint hx = hash_eat(hash, int(cell_x));
	uint hy = hash_eat(hash, int(cell_y));

	vec2 cell_size = chunk_params.zz / chunk_params.w;

	float x = chunk_params.x + (cell_x + hash_get_float(hx)) * cell_size.x;
	float y = chunk_params.y + (cell_y + hash_get_float(hy)) * cell_size.y;

	vec2 uv = vec2(
		(x + world_params.x) / world_params.z,
		(y + world_params.y) / world_params.z
	);

	float z = sample_height(x, y);

	// Eat some prime numbers to get variation, quite arbitrary, and could do without
	// float h_noise = sample_height(x * 3, y * 3) / noise_params.z;
	float h = grass_params.x + grass_params.y * (hash_get_float(hash_eat(hash, 13)));
	float r = hash_get_float(hash_eat(hash, 37)) * 2 * pi;

	// Todo(Leo): this piece of code is supposed to remove unplaceable grass blades
	// but for now we just scale them to zero. Please fix if possible.
	float placement_value = textureLod(placement_texture, uv, 0).r;
	if (placement_value < 0.5) {
		// h = 0.0;
		instances[index].width = 0;
		instances[index].height = 0;
		return;
	}

	// base position before clumping
	vec3 position = vec3(x, y, z);

	/// test voronoi hashing
	float voronoi_cell_size = noise_params.w;
	int vx = int(floor(x / voronoi_cell_size));
	int vy = int(floor(y / voronoi_cell_size));

	vec2 pos = vec2(x, y);

	ivec2 closest_cell;
	vec2 closest_position;
	float closest_distance = 10000;
	for (int i = 0; i < 9; i += 1) {

		int xx = vx + (i % 3) - 1;
		int yy = vy + (i / 3) - 1;

		vec2 vpos = (vec2(xx, yy) + random_vec2(ivec2(xx, yy))) * voronoi_cell_size;

		float distance = length(vpos - pos);
		if (distance < closest_distance) {
			closest_distance = distance;
			closest_cell = ivec2(xx, yy);
			closest_position = vpos;
		}
	}
	uint clump_hash 	= hash_eat(hash_make(closest_cell.x), closest_cell.y);
	float extra_height 	= hash_get_float(clump_hash) * 0.8;

	vec3 clump_position = vec3(closest_position, sample_height(closest_position.x, closest_position.y));
	vec3 to_clump 		= clump_position - position;

	instances[index].position 	= position + to_clump * 0.1;
	instances[index].test_color = random_color(closest_cell.x + 2000 * closest_cell.y);
	instances[index].field_uv 	= uv;
	instances[index].height 	= h + extra_height;
	instances[index].width 		= grass_params.z;
	instances[index].bend 		= grass_params.w;
	instances[index].facing 	= vec2(-sin(r), cos(r));
}
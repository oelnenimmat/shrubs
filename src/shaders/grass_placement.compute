#version 450

///////////////////////////////////////////////////////////////////////////////
// Noise section, move this to a different file so everyone can use

const uint PRIME_A = 2654435761;
const uint PRIME_B = 2246822519;
const uint PRIME_C = 3266489917;
const uint PRIME_D = 668265263;
const uint PRIME_E = 374761393;

uint hash_make (int seed) {
	return uint(seed) + PRIME_E;
}

uint rotate_left(uint data, uint steps) {
	return (data << steps) | (data >> (32 - steps));
}

uint hash_eat (uint hash, int data) {
	return rotate_left(hash + uint(data) * PRIME_C, 17) * PRIME_D;
}

uint hash_get_uint (uint hash) {
	uint avalanche = hash;
	avalanche = avalanche ^ (avalanche >> 15);
	avalanche *= PRIME_B;
	avalanche = avalanche ^ (avalanche >> 13);
	avalanche *= PRIME_C;
	avalanche = avalanche ^ (avalanche >> 16);
	return avalanche;
}

float hash_get_float (uint hash) {
	return float(hash_get_uint(hash)) / 4294967295.0;
}

vec3 random_color (int seed) {
	uint hash = hash_make(seed);
	return vec3 (
		hash_get_float(hash_eat(hash, int(PRIME_A))),
		hash_get_float(hash_eat(hash, int(PRIME_C))),
		hash_get_float(hash_eat(hash, int(PRIME_E)))
	);
}

vec2 random_vec2 (ivec2 seed) {
	return vec2 (
		hash_get_float(hash_eat(hash_make(seed.x), seed.y)),
		hash_get_float(hash_eat(hash_make(seed.y), seed.x))
	);
}

float value_noise_2D(float x, float y, int seed) {
	int ix0 = int(floor(x));
	int ix1 = ix0 + 1;
	float tx = smoothstep(0, 1, x - ix0);

	int iy0 = int(floor(y));
	int iy1 = iy0 + 1;
	float ty = smoothstep(0, 1, y - iy0);

	uint h = hash_make(seed);

	uint h0 = hash_eat(h, ix0);
	uint h1 = hash_eat(h, ix1);

	uint h00 = hash_eat(h0, iy0);
	uint h10 = hash_eat(h1, iy0);
	uint h01 = hash_eat(h0, iy1);
	uint h11 = hash_eat(h1, iy1);

	float v00 = hash_get_float(h00);
	float v10 = hash_get_float(h10);
	float v01 = hash_get_float(h01);
	float v11 = hash_get_float(h11);

	float v0 = mix(v00, v10, tx);
	float v1 = mix(v01, v11, tx);

	float v = mix(v0, v1, ty);

	return v;
}

// End noise section
///////////////////////////////////////////////////////////////////////////////

const float pi = 3.14159265359;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

uniform sampler2D placement_texture;

// Todo(Leo): get this from placement map
uniform int type_index;

// x: world_seed;
// y: world_to_grid_scale;
// z: terrain_z_scale;
uniform vec4 noise_params;

// xy: chunk min corner position xy
// z: chunk size xy (Todo(Leo): constant?)
// w: grass blades in chunk 1D (Todo(Leo): constant?)
uniform vec4 chunk_params;

// xy: world min corner position xy
// z: world size xy
uniform vec4 world_params;

struct GrassTypeData {
	float base_height;
	float height_variation;
	float width;
	float bend;

	float clump_size;
	float clump_height_variation;
	float clump_squeeze_in;

	float _more_data;

	vec4 top_color;
	vec4 bottom_color;
	float roughness;

	float _more_data_2;
	float _more_data_3;
};

struct GrassInstanceData {
	vec3 	position;
	float 	rotation;
	vec2 	field_uv;
	float 	height;
	float 	width;
	vec3 	test_color;
	float 	bend;
	vec2 	facing;
	uint 	type_index;
	float 	_more_data;
};

layout (std140, binding = 10) uniform grass_types {
	GrassTypeData types[];
};

layout (std430, binding = 11) buffer grass_instances {
	GrassInstanceData instances [];
};

float sample_height (float x, float y) {
	// transform to grid scale
	x *= noise_params.y;
	y *= noise_params.y;

	return value_noise_2D(x, y, int(noise_params.x)) * noise_params.z;
}

void main() {
	uint index = gl_GlobalInvocationID.x + 
				uint(chunk_params.w) * gl_GlobalInvocationID.y;
	uint cell_x = gl_GlobalInvocationID.x;
	uint cell_y = gl_GlobalInvocationID.y;

	// Todo(Leo): make hash based on base position, not index, to not swap hash when
	// blending lods
	uint hash = hash_make(int(index));
	uint hx = hash_eat(hash, int(cell_x));
	uint hy = hash_eat(hash, int(cell_y));

	vec2 cell_size = chunk_params.zz / chunk_params.w;

	float x = chunk_params.x + (cell_x + hash_get_float(hx)) * cell_size.x;
	float y = chunk_params.y + (cell_y + hash_get_float(hy)) * cell_size.y;
	float z = sample_height(x, y);

	vec2 uv = vec2(
		(x + world_params.x) / world_params.z,
		(y + world_params.y) / world_params.z
	);

	// Todo(Leo): this piece of code is supposed to remove unplaceable grass blades
	// but for now we just scale them to zero. Please fix if possible.
	float placement_value = textureLod(placement_texture, uv, 0).r;
	if (placement_value < 0.5) {
		instances[index].position = vec3(0);
		instances[index].width = 0;
		instances[index].height = 0;
		return;
	}

	// Eat some prime numbers to get variation, quite arbitrary, and could do without
	// float h_noise = sample_height(x * 3, y * 3) / noise_params.z;
	float h = types[type_index].base_height + types[type_index].height_variation * (hash_get_float(hash_eat(hash, 13)));
	float r = hash_get_float(hash_eat(hash, 37)) * 2 * pi;

	// base position before clumping
	vec3 position = vec3(x, y, z);

	// test voronoi hashing
	float clump_cell_size = types[type_index].clump_size;
	int vx = int(floor(x / clump_cell_size));
	int vy = int(floor(y / clump_cell_size));

	vec2 pos = vec2(x, y);

	ivec2 closest_cell;
	vec2 closest_position;
	float closest_distance = 10000;
	for (int i = 0; i < 9; i += 1) {

		int xx = vx + (i % 3) - 1;
		int yy = vy + (i / 3) - 1;

		vec2 vpos = (vec2(xx, yy) + random_vec2(ivec2(xx, yy))) * clump_cell_size;

		float distance = length(vpos - pos);
		if (distance < closest_distance) {
			closest_distance = distance;
			closest_cell = ivec2(xx, yy);
			closest_position = vpos;
		}
	}
	uint clump_hash 	= hash_eat(hash_make(closest_cell.x), closest_cell.y);
	float extra_height 	= pow(hash_get_float(clump_hash), 3) * types[type_index].clump_height_variation;

	vec3 clump_position = vec3(closest_position, sample_height(closest_position.x, closest_position.y));
	vec3 to_clump 		= clump_position - position;
	position 			= position + to_clump * types[type_index].clump_squeeze_in;
	position.z 			= sample_height(position.x, position.y);

	instances[index].position 	= position;
	instances[index].test_color = random_color(closest_cell.x + 2000 * closest_cell.y);
	instances[index].field_uv 	= uv;
	instances[index].height 	= h + extra_height;
	instances[index].width 		= types[type_index].width;
	instances[index].bend 		= types[type_index].bend;
	instances[index].facing 	= vec2(-sin(r), cos(r));

	instances[index].type_index = type_index;
}